<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8" />
	<meta name="theme-color" content="#cccccc" />
	<meta http-equiv="X-UA-Compatible" content="IE=edge" />
	<title>Network Performance Kernel for Progressive Web Applications</title>
	<meta name="description" content="Network Performance Kernel for Progressive Web Applications" />
	<meta name="apple-mobile-web-app-capable" content="yes">
	<meta name="apple-mobile-web-app-status-bar-style" content="#cccccc">
	<meta name="apple-mobile-web-app-title" content="Network Performance Kernel">
	<meta name="msapplication-TileImage" content="">
	<meta name="msapplication-TileColor" content="#cccccc">
	<link href="" rel="apple-touch-icon">
	<link href="/manifest.json" rel="manifest" />
	<style>
	<!-- Critical rendering path - Above-the-fold & font defintions -->
	<!-- 
						

























	-->
	</style>
</head>
<body>

<h1>Content Body</h1>

<img src="/images/test_pattern.png"/>

<p>Last Kbps: <span id="kbps_output">0.00</span> (<span id="mbps_output">0.00</span> Mbps)</p>
<p>TransferSize: <span id="resource_output">0</span></p>

<!-- Noscript fallovers go here -->
<noscript>
<link href="" type="text/css" rel="stylesheet" />
</noscript>

<script>
'use strict';

/* NPK constructor */
var __npk = function(debug=false) {
	/* 
	 * Global declairations 
	 */
	this.debug  = debug;

	this.ping    = true;
	this.stream  = true;

	/* 
	 * Mode Callbacks 
	 */
	this.onNonInteractiveLoad   = function() { }; // Callback
	this.onNonInteractiveLoaded = false;          // Changes to true

	this.onInteractiveLoad       = function() { }; // Callback
	this.onInteractiveLoadLoaded = false;          // Changes to true

	this.onCustomThresholdLoad   = function() { }; // Callback
	this.onCustomThresholdLoaded = false;          // Changes to true
 
	/* 
	 * Threshold in kpbs for interactive to non interactive (10kbps is very slow :))
	 */
	this.threshold = 10;

	/* 
	 * Mode Callbacks 
	 */
	this.nonint = -2;
	this.stdint = -1;

	this.bundles = [];
	this.modules = [];

	this.bundle = {};
	this.module = {};

	/* 
	 * Envornment Variables
	 */

	/* setResourceTimingBufferSize 
	 * For better overall production performance reducing this will save memory I suggest no less than 10
     	 * Note - This is causing problems once the buffer hits because the browser doesn't keep this tidy both in FF and Chrome
	 */
	this.setResourceTimingBufferSize = 100;

	/* Timers */
	this.startLoadTime = 0;
	this.domLoadTime   = 0
};

var __npk__ = new __npk(true);

/* The bundling and module defintions */

// A Non-interactive definition
__npk__.bundle = {
			'threshold'       : __npk__.nonint,
			'label'       	  : 'optional',              // Not sure if its needed but we'll have it for now
			'type'            : 'initial',               // Initial means we'll download respecitivly of performance (default for noinit)
			'method'          : 'promise|element|xhr',   // Load method we should make this for each object that way we can introduce streaming media and web assembly objects
			'max_media'       : false,                   // Determine media max (optional) (untested)
			'min_media'       : false,                   // Determine media min (optional) (untested)
			'useragent'       : false,                   // Load based on useragent (optional) (untested)
			// Loading our vendors (here the difference is that vendors are loaded first)
			'vendor_js'       : ['vendor.js|style=blah|deferred=deferred',
								'vendor2.js'],
			'vendor_css'      : ['vendor.css'],
			// Loading the app here vendors here
			'scripts'         : ['app.js|style=blah|deferred=true',
								'app2.js'],
			'styles'          : ['style.css'],
			// initialisers that will run after all has loaded (optional)
			'onload'   	      : function() { },   // event callback after the whole bundle has loaded
			'onscriptload'    : function() { },   // event callback after scripts have loaded
			'onstyleload'     : function() { },   // event callback after styles have loaded
		 };     
__npk__.bundles.push(__npk__.bundle);

// An interactive defintion
__npk__.bundle = {
			'threshold'   : __npk__.stdint, // We can have more than one of these based on resolution and breakpoint
			'type'        : 'inherit',
			'breakpoint'  : false,
			'min-width'   : false,
			'max-width'   : false,
			'vendor_js'   : ['vendor.js'],
			'scripts'     : ['app.js'],
			'vendor_css'  : ['vendor.css'],
			'styles'      : ['app.css'] 
		 };
__npk__.bundles.push(__npk__.bundle);

// Custom defintion 1
__npk__.bundle = {
			'threshold'   : 2000, // Set at Kpbs I.E 2000kpbs
			'type'        : 'inherit',
			'breakpoint'  : false,
			'min-width'   : false,
			'max-width'   : false,
			'vendor_js'   : ['vendor.js'],
			'scripts'     : ['app.js'],
			'vendor_css'  : ['vendor.css'],
			'styles'      : ['app.css'] 
		 };
__npk__.bundles.push(__npk__.bundle);

// Custom defintion 2
__npk__.bundle = {
			'threshold'   : 5000, // Hi def mode at 5000kpbs
			'type'        : 'inherit',
			'vendor_js'   : ['vendor.js'],
			'scripts'     : ['app.js'],
			'vendor_css'  : ['vendor.css'],
			'styles'      : ['app.css'] 
		 };
__npk__.bundles.push(__npk__.bundle);

// Module defintion 1
__npk__.module = {
			'scripts'       : ['/build/sw_cache.js|deferred|type="text/javascript"', 'module2.js'],
			'onload'        : function() { 
				/* Serviceworker config or importer goes here */
				return true;
		    } 
		 };
__npk__.modules.push(__npk__.module);

// Module defintion 2
__npk__.module = {
			'scripts'     : ['script.js', 'module2.js'],
			'styles'      : ['steyle.css'],
			'onload'      : function() { } 
		 };
__npk__.modules.push(__npk__.module);

/* End of bundling and module defintions */

if(__npk__.debug) {
	__npk__.startLoadTime = (new Date()).getTime();

	console.log('Debug: true');

	document.addEventListener('DOMContentLoaded', function() { 
		__npk__.domLoadTime = (new Date()).getTime(); 
		console.log('DOMContentLoaded: '+(__npk__.domLoadTime-__npk__.startLoadTime)+'ms'); 
	});
}

if(__npk__.setResourceTimingBufferSize && typeof performance.clearResourceTimings === 'function');
	performance.setResourceTimingBufferSize(__npk__.setResourceTimingBufferSize);

/* __npk_ping(); */
var __npk_ping = function() {
	// Every __ping_interval we will perform the ping (default 30secs)
	this.ping_interval = false;

	// The network performance of the last ping test (do not modify)
	this.ping_kbps = -1;

	// Ping configuration
	this.ping_url = window.location.protocol+'//'+window.location.hostname+'/ping.png';

	/* Only used for browsers that do not support transferSize (Safari). 
	 * Tip make sure it matches the size of the ping object further, 
	 * Further a drawback to this method is that there maybe a few octets 
	 * above or below that get sent during transmission that may cause minor inacuracy
	 */
	this.ping_payload_size = 3008; 

	this.ping_buffer      = [];
	this.ping_buffer_kpbs = [];

	this.ping_buffer_inc = 0;
	this.ping_buffer_max = 5;
};

/* __npk_ping.prototype.ping - NPK ping tool to determine network speed
 * We need to watch memory here as the network performance object will continue to increase even though we are redefining 
 * the Image object with the the range for 5 images, further to note, each ping is no more than 1-2kb respecitivly
 * Note: we need to test the backward compatability for ping.
 * Note II: Create API reference for ping to be used
 */
__npk_ping.prototype.ping = function(callback) {
	if(__npk__.debug) {
		console.log('Ping?');
	}
    
	if(this.ping_buffer_inc>this.ping_buffer_max) {  
		this.ping_buffer_inc = 0; 
	}

	var rand = Math.random().toString(36).substr(2, 10).toLowerCase();

	this.ping_buffer[this.ping_buffer_inc]     = new Image();
	this.ping_buffer[this.ping_buffer_inc].src = this.ping_url+'?='+rand;

	if(typeof performance === 'undefined') {
		var fetchStart = (new Date()).getTime();
	}

	this.ping_buffer[this.ping_buffer_inc].onload = (function() { 
		if(__npk__.debug) {
			console.log('Pong!');
		}

		if(typeof performance === 'undefined') {
			var responseEnd = (new Date()).getTime();

			var transferTime = (responseEnd-fetchStart)/1000;
			var transferSize = this.ping_payload_size;
		} else {
			var entries    = performance.getEntriesByName(this.ping_url+'?='+rand);
			var last_entry = entries[entries.length-1];

			var transferTime = (last_entry.responseEnd-last_entry.fetchStart)/1000;

			if("transferSize" in last_entry) {
				var transferSize = last_entry.transferSize;
			} else {
				var transferSize = this.ping_payload_size;
			}
		}

		// To kpbs a further 1024 for mbps
		this.ping_buffer_kpbs[this.ping_buffer_inc] = ((transferSize*8)/transferTime)/1024;

		// Save to the NPK
        	this.ping_kbps = this.ping_buffer_kpbs[this.ping_buffer_inc];
		
		if(__npk__.debug) {
			console.log(this.ping_kbps);
		}

		if(callback && typeof callback === 'function') {
			callback();
		}
	}).bind(this);

	this.ping_buffer_inc++;

	if(this.ping_interval) {
	    setTimeout((function() { this.ping(); }).bind(this), this.ping_interval);
	}

    return true;
};

if(__npk__.ping) {
	var __npk_ping__ = new __npk_ping();

	/* __npk_ping__.ping(); */
	__npk_ping__.ping(); 
	/* __npk_ping__.ping(); */
}

/* npk loading routeens */
var __npk_loader = function() {
	this.body = document.body;

	this.bundle_scripts = [];
	this.bundle_styles  = [];

	this.module_scripts = [];
	this.module_styles  = [];

	this.accepted_bundles   = [];
	this.unaccepted_bundles = [];

	this.viewport_w = window.innerWidth  || document.documentElement.clientWidth  || document.body.clientWidth;
	this.viewport_h = window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight;

	this.useragent = navigator.userAgent;

	this.li_tally = 0;

	this.archived_scripts = [];
	this.archived_styles  = [];

	/* navigator.appCodeName
	navigator.appName
	navigator.appVersion
	navigator.cookieEnabled
	navigator.language
	navigator.onLine
	navigator.platform
	navigator.userAgent*/

	this.elements = {
		script : { tag : 'script', link : 'src',  attributes : { type : 'text/javascript' } },
		style  : { tag : 'link',   link : 'href', attributes : { type : 'text/css', rel : 'stylesheet', media : 'screen, print' } },
	};
};

__npk_loader.prototype.loadObjectByElement = function(type, file, argc, id, success, error) {
	if(typeof this.elements[type] === 'undefined' || file === 'undefined') {
		return null;
	}

	var attributes = this.elements[type].attributes;
	var element = document.createElement(this.elements[type].tag);
	var link = this.elements[type].link;

	//this.elements[type].link = file;
	element.setAttribute(link, file);

	if(typeof id !== 'undefined' && (typeof id === 'string' || id instanceof String)) {
		//element.setAttribute('id', id);
	}

	Object.keys(attributes).forEach(function(key) {
		element.setAttribute(key, attributes[key]);
	});

	if(typeof argc !== 'undefined' && (typeof argc === 'string' || argc instanceof String)) {
		var argv = argc.split('|');
	}

	if(typeof argv !== 'undefined' && argv.length>1) {
		for(var i=0; i<argv.length; i++) { 
			var values = argv[i].split('=');
			if(values.length>1) {
				element.setAttribute(values[0], values[1]);
			} else {
				element.setAttribute(values[0], '');
			}
		}
	}

	return element;
};

__npk_loader.prototype.createLoadObjects = function(input, output_scripts, output_styles, ids) {
	// Record only the filename
	for(var x=0; output_scripts.length>x; x++) { 
		this.archived_scripts.push(output_scripts[x].file);
	}
	for(var x=0; output_styles.length>x; x++) {
		this.archived_styles.push(output_styles[x].file);
	}

	// Flush both arrays before using
	while(output_scripts.length) { output_scripts.pop(); }
	while(output_styles.length) { output_styles.pop(); }

	for(var x=0; input.length>x; x++) {
		if(typeof input[x].scripts !== 'undefined' && typeof input[x].accepted !== 'undefined') {
			for(var y=0; input[x].scripts.length>y; y++) {
				var string = input[x].scripts[y].split('|');
				var found = false;

				for(var z=0; output_scripts.length>z; z++) {
					if(output_scripts[z].file === string[0]) {
						output_scripts[z][ids].push(x);
						found = true;
					}
				}
				
				if(this.archived_scripts.length>0) {
					for(var z=0; this.archived_scripts.length>z; z++) { 
						if(this.archived_scripts[z].toLowerCase() == string[0].toLowerCase()) { 
							found = true;
						}
					}
				}

				if(found === false) { 
					var script = { [ids]: [] };
					// we need to set the default script behavior here
					script[ids].push(x);
					script.file           = string[0];
					script.attributes     = string.slice(1).join('|');
					script.loaded         = false;
					script.error          = false;
									
					output_scripts.push(script); 
				}
			}
		}

		if(typeof input[x].styles !== 'undefined' && typeof input[x].accepted !== 'undefined') {
			for(var y=0; input[x].styles.length>y; y++) {
				var string = input[x].styles[y].split('|');
				var found = false;

				for(var z=0; output_styles.length>z; z++) {
					if(output_styles[z].file === string[0]) {
						output_styles[z][ids].push(x);
						found = true;
					}
				}

				if(this.archived_styles.length>0) {
					for(var z=0; this.archived_styles.length>z; z++) { 
						if(this.archived_styles[z].toLowerCase() == string[0].toLowerCase()) { 
							found = true;
						}
					}
				}

				if(found === false) {
					var style = { [ids]: [] };
					// we need to set the default style behavior here
					style[ids].push(x);
					style.file           = string[0];
					style.attributes     = string.slice(1).join('|');
					style.loaded         = false;
					style.error          = false;

					output_styles.push(style); 
				}
			}

			// Maybe we delete this one later
			delete input[x].accepted;
		}
	}

	return true;
};


__npk_loader.prototype.createModuleLoadObjects = function() {
	return this.createLoadObjects(__npk__.modules, this.module_scripts, this.module_styles, 'moduleids');
};

/* Note: do not call this again until Loadbundle has finished */
__npk_loader.prototype.createBundleLoadObjects = function(fallover=false, stdint=false) {
	// Clear variables before use
	for(var x=0; __npk__.bundles.length>x; x++) { 
		delete __npk__.bundles[x].accepted; 
		delete __npk__.bundles[x].unaccepted; 
	}

	if(typeof __npk_ping__ !== 'undefined') {
		var kbps = Number((__npk_ping__.ping_kbps).toFixed(2));
	} else {
		var kbps = -1;
	}

	for(var x=0; __npk__.bundles.length>x; x++) {
		if(typeof __npk__.bundles[x].loaded === 'undefined') {
			var pass = true;
			var accepted = false;

			/* Filter out viewports that dont match (untested)
			 * We should make it so just one of the following is set but for now we compare for the two togeather
			 */
			if((__npk__.bundles[x].min_media !== 'undefined' && __npk__.bundles[x].min_media > 0) &&
			   (__npk__.bundles[x].max_media !== 'undefined' && __npk__.bundles[x].max_media > 0)) {
				if(!(this.viewport_w >= __npk__.bundles[x].min_media && this.viewport_w <= __npk__.bundles[x].max_media) ||
				   !(this.viewport_h >= __npk__.bundles[x].min_media && this.viewport_h <= __npk__.bundles[x].max_media)) {
					pass = false;
				}
			} 

			/* Filter out useragents that dont match (untested)
			 * This feature can be expanded using the globals found under navigator such as platform
			 */ 
			if(typeof __npk__.bundles[x].useragent !== 'undefined' && typeof __npk__.bundles[x].useragent === 'string') {
				if(__npk__.bundles[x].useragent.test(this.useragent) === false) {
					pass = false;
				}
			} 

			if(pass === true) {
				/* Fallover mode will just load the non-interactive bundles */
				if(fallover === true && __npk__.bundles[x].threshold === __npk__.nonint) {
					accepted = true;
				/* Load only interactive modules */
				} else if(stdint === true && __npk__.bundles[x].threshold === __npk__.stdint) {
					accepted = true;
				/* No ping mode will just load all libries in consecutive order but only as a low priority
				 * TODO: We should set this so no ping and no stream loads everything and stream with no ping 
				 * loads non interactive andthen interactive later 
				 */
				} else if(typeof __npk_ping__ === 'undefined') {
					accepted = true;
				/* Otherwise load based on ping priority */
				} else { 
					if(__npk__.bundles[x].threshold === __npk__.nonint) {
						accepted = true;
					} else if(__npk__.bundles[x].threshold === __npk__.stdint && __npk__.threshold <= kbps) {
						accepted = true;
					} else if(__npk__.bundles[x].threshold > 0 && __npk__.bundles[x].threshold <= kbps) {
						accepted = true;
					}
				} 
			}

			if(accepted === true) {
				if(__npk__.debug) { 
					console.log('Accepted bundle');
					console.log(__npk__.bundles[x]); 
				}
				if(typeof __npk__.bundles[x].type === 'undefined' || __npk__.bundles[x].type === 'inherit') {
					__npk__.bundles[x].accepted = true;
				} else if(__npk__.bundles[x].type === 'initial') {
					// clear and start allover
					for(var y=0; __npk__.bundles.length>y; y++) { delete __npk__.bundles[y].accepted; }
					__npk__.bundles[x].accepted = true;
				} 
			} else {
				if(__npk__.debug) { 
					console.log('Unaccepted bundle');
					console.log(__npk__.bundles[x]); 
				}
				__npk__.bundles[x].unaccepted = true;
			}	
		}
	}

	/* If stream mode is set let's check the current set of bundles and load the next volly of bundles if needed
	 * Note: this may become recursive in the future to account for custom thresholds after interactive but 
	 * for now we stop at just interactive mode defined under __npk_loader.prototype.loadInteractive() */
	if(__npk__.stream) { 
		var interactive = true;
		var bundle_length = 0;

		for(var x=0; __npk__.bundles.length>x; x++) { 
			if(typeof __npk__.bundles[x].accepted !== 'undefined') { 
				bundle_length++;

				if(__npk__.bundles[x].threshold !== __npk__.nonint) { 
					interactive = false;
				}
			}
		}

		if(interactive === true && bundle_length>0) { 
			for(var x=0; __npk__.bundles.length>x; x++) { 
				if(typeof __npk__.bundles[x].accepted !== 'undefined') {
					__npk__.bundles[x]._onload = function() { __npk_loader__.loadInteractive(bundle_length); };
				}
			}
		}
	}

	return this.createLoadObjects(__npk__.bundles, this.bundle_scripts, this.bundle_styles, 'bundleids');
};


/* __npk_loader.prototype.loadInteractive - We need to create an API reference for this function.
 * Note: The counter allows for all bundles to be loaded, we should make it so we can 
 * dedicate its own variable to each group but for now we'll just rely on __npk_loader__.li_tally
 */
__npk_loader.prototype.loadInteractive = function(count=false) { 
	var execute = false;

	if(count) {
		__npk_loader__.li_tally++
		if(__npk_loader__.li_tally === count) { 
			__npk_loader__.li_tally = 0;
			execute = true;
		}
	} else {
		execute = true;
	}

	if(execute) { 
		/* Note that simply reloading createBundleHierarchy which should filter out any of the already loaded bundles 
		 * What needs to happen here is something different, we need to set a mode that forces only interactive 
         	 * to load leaving the upper thresholds */
		if(__npk_loader__.createBundleLoadObjects(false, true)) {
			__npk_loader__.loadBundles();
		}
	}
};

/* __npk_loader.prototype.checkObjectStatus - Used to check the callback of an object being loaded
 *
 */
__npk_loader.prototype.checkObjectStatus = function(object, output_scripts, output_styles, ids) { 
	var noninteractive  = false;
	var stdinteractive  = false;
	var customthreshold = false;

	for(var x=0; object.length>x; x++) {
		var id = x;

		var scripts  = object[x].scripts;
		var styles   = object[x].styles;

		if(typeof scripts !== 'undefined' && typeof object[x].scripts_loaded === 'undefined') {
			var scripts_tally = 0;
			var scripts_tally_offset = 0;

			for(var y=0; output_scripts.length>y; y++) { 
				for(var z=0; output_scripts[y][ids].length>z; z++) {
					if(output_scripts[y][ids][z]===id) { 
						if(output_scripts[y].loaded === true) { 
							scripts_tally++;
						} 
						if(output_scripts[y].error === true) { 
							scripts_tally_offset++;
						} 
					}
				}

				// All scripts have loaded
				if((scripts.length-scripts_tally_offset)<=scripts_tally) { 
					object[x].scripts_loaded = true;

					if(typeof object[x].onscriptload !== 'undefined' && typeof object[x].onscriptload === 'function') {
						object[x].onscriptload();
					}
					if(typeof object[x]._onscriptload !== 'undefined' && typeof object[x]._onscriptload === 'function') {
						object[x]._onscriptload();
					}
				}
			}
		}

		if(typeof styles !== 'undefined' && typeof object[x].styles_loaded === 'undefined') {
			var styles_tally  = 0;
			var styles_tally_offset = 0;

			for(var y=0; output_styles.length>y; y++) {

				for(var z=0; output_styles[y][ids].length>z; z++) {
					if(output_styles[y][ids][z]===id) { 
						if(output_styles[y].loaded === true) { 
							styles_tally++;
						} 
						if(output_styles[y].error === true) { 
							styles_tally_offset++;
						} 
					}
				}

				// All styles have loaded
				if((styles.length-styles_tally_offset)<=styles_tally) {
					object[x].styles_loaded = true;

					if(typeof object[x].onstyleload !== 'undefined' && typeof object[x].onstyleload === 'function') {
						object[x].onstyleload();
					}
					if(typeof object[x]._onstyleload !== 'undefined' && typeof object[x]._onstyleload === 'function') {
						object[x]._onstyleload();
					}
				}
			}
		}

		// All scripts and styles have loaded 
		if(typeof object[x].loaded === 'undefined') {
			if((typeof scripts === 'undefined' || typeof object[x].scripts_loaded !== 'undefined') && 
			   (typeof styles  === 'undefined' || typeof object[x].styles_loaded  !== 'undefined')) {
				object[x].loaded = true;

				if(typeof object[x].onload !== 'undefined' && typeof object[x].onload === 'function') {
					object[x].onload();
				}
				if(typeof object[x]._onload !== 'undefined' && typeof object[x]._onload === 'function') {
					object[x]._onload();
				}
			}
		}

		switch(object[x].threshold) {
			case __npk__.nonint: 
				if(typeof object[x].loaded !== 'undefined') {
					noninteractive = true;
				} else {
					noninteractive = false;
				}
				break;

			case __npk__.stdint: 
				if(typeof object[x].loaded !== 'undefined') {
					stdinteractive = true;
				} else {
					stdinteractive = false;
				}
				break;

			default:
				if(typeof object[x].loaded !== 'undefined') {
					customthreshold = true;
				} else {
					customthreshold = false;
				}
				break;
		};
	}

	// Group Callbacks
	if(noninteractive === true && __npk__.onNonInteractiveLoaded !== true) {
		if(typeof __npk__.onNonInteractiveLoad !== 'undefined' && typeof __npk__.onNonInteractiveLoad === 'function') {
			__npk__.onNonInteractiveLoad();
		}
		__npk__.onNonInteractiveLoaded = true;
	}
	if(stdinteractive === true && __npk__.onInteractiveLoadLoaded !== true) { 
		if(typeof __npk__.onNonInteractiveLoad !== 'undefined' && typeof __npk__.onNonInteractiveLoad === 'function') {
			__npk__.onInteractiveLoad();
		}
		__npk__.onInteractiveLoadLoaded = true;
	}
	if(customthreshold === true && __npk__.onCustomThresholdLoaded !== true) { 
		if(typeof __npk__.onCustomThresholdLoaded !== 'undefined' && typeof __npk__.onCustomThresholdLoaded === 'function') {
			__npk__.onCustomThresholdLoaded();
		}
		__npk__.onCustomThresholdLoaded = true;
	}

	return true;
};

__npk_loader.prototype.checkModuleStatus = function() { 
	return this.checkObjectStatus(__npk__.modules, this.module_scripts, this.module_styles, 'moduleids');
};

__npk_loader.prototype.checkBundleStatus = function() { 
	return this.checkObjectStatus(__npk__.bundles, this.bundle_scripts, this.bundle_styles, 'bundleids');
};

__npk_loader.prototype.setCallbackVariable = function(_url, type, variable, value) {
	if(typeof _url === 'undefined' || _url.length<1) {
		return false;
	}

	// Set to lowercase
	var url = _url.toString().toLowerCase();

	// Differentiate between local and external objects, may need to be compliance checked
	if(url.startsWith((window.location.protocol+'//'+window.location.hostname).toLowerCase())) {
		var file = url.replace(/^(?:\/\/|[^\/]+)*\//, "");
	} else {
		var file = url;
	}

	for(var x=0; this[type].length>x; x++) { 
		if(this[type][x].file === file) {
			this[type][x][variable] = value;
		}
	}
};

__npk_loader.prototype.loadModules = function() {
	var scripts  = document.createElement("div");
	var styles   = document.createElement("div");

	scripts.id = 'module_scripts';
	styles.id  = 'module_styles';

	for(var x=0; this.module_scripts.length>x; x++) { 
		if(typeof this.module_scripts[x] !== 'undefined') {	
			var script = this.loadObjectByElement('script', this.module_scripts[x].file, this.module_scripts[x].attributes, '');

			if(script) {
	 			script.onload = script.onreadystatechange = function() { __npk_loader__.setCallbackVariable(this.src, 'module_scripts', 'loaded', true); __npk_loader__.checkModuleStatus(); };
				script.onerror = function() { __npk_loader__.setCallbackVariable(this.src, 'module_scripts', 'error', true); __npk_loader__.checkModuleStatus(); };

				scripts.appendChild(script);
			}
		}
	}

	for(var x=0; this.module_styles.length>x; x++) {
		if(typeof this.module_styles[x] !== 'undefined') {
			var style = this.loadObjectByElement('style', this.module_styles[x].file, this.module_styles[x].attributes, '');

			if(style) {
	 			style.onload = style.onreadystatechange = function() {__npk_loader__.setCallbackVariable(this.href, 'module_styles', 'loaded', true); __npk_loader__.checkModuleStatus(); };
				style.onerror = function() {  __npk_loader__.setCallbackVariable(this.href, 'module_styles', 'error', true); __npk_loader__.checkModuleStatus(); };

				styles.appendChild(style);
			}
		}
	}

	document.body.appendChild(scripts);
	document.body.appendChild(styles);

	if(__npk__.debug) {
		console.log('Module loader output');
		console.log(scripts);
		console.log(styles);
	}
};

// Logic for the load process
__npk_loader.prototype.loadBundles = function() {
	var scripts  = document.createElement("div");
	var styles   = document.createElement("div");

	scripts.id = 'bundle_scripts';
	styles.id  = 'bundle_styles';

	for(var x=0; this.bundle_scripts.length>x; x++) { 
		if(typeof this.bundle_scripts[x] !== 'undefined') {	
			var script = this.loadObjectByElement('script', this.bundle_scripts[x].file, this.bundle_scripts[x].attributes, '');

			if(script) {
	 			script.onload = script.onreadystatechange = function() { __npk_loader__.setCallbackVariable(this.src, 'bundle_scripts', 'loaded', true); __npk_loader__.checkBundleStatus(); };
				script.onerror = function() { __npk_loader__.setCallbackVariable(this.src, 'bundle_scripts', 'error', true); __npk_loader__.checkBundleStatus(); };

				scripts.appendChild(script);
			}
		}
	}

	for(var x=0; this.bundle_styles.length>x; x++) {
		if(typeof this.bundle_styles[x] !== 'undefined') {
			var style = this.loadObjectByElement('style', this.bundle_styles[x].file, this.bundle_styles[x].attributes, '');

			if(style) {
 				style.onload = style.onreadystatechange = function() { __npk_loader__.setCallbackVariable(this.href, 'bundle_styles', 'loaded', true); __npk_loader__.checkBundleStatus(); };
				style.onerror = function() { __npk_loader__.setCallbackVariable(this.href, 'bundle_styles', 'error', true); __npk_loader__.checkBundleStatus(); };

				styles.appendChild(style);
			}
		}
	}

	document.body.appendChild(scripts);
	document.body.appendChild(styles);

	if(__npk__.debug) {
		console.log('Bundle loader output');
		console.log(scripts);
		console.log(styles);
	}
};

var __npk_loader__ = new __npk_loader();

/*
 * __npk_init_modules 
 */
var __npk_init_modules = function() {
	if(__npk__.debug) {
		console.log('Running Modules ...');
	}

	/* __npk_loader__.createModuleLoadObjects() */
	__npk_loader__.createModuleLoadObjects();
	/* __npk_loader__.createModuleLoadObjects() */

	/* __npk_loader__.loadModules() */
	__npk_loader__.loadModules();
	/* __npk_loader__.loadModules() */
	
    return true;
};

/*
 * __npk_init - NPK init
 */
var __npk_init = function(fallover=false) { 
	if(__npk__.debug) {
		if(fallover === true) {
			console.log('Running Init ... [Fallover Mode!]');
		} else {
			console.log('Running Init ...');
		}
	}

	if(typeof __npk_ping__ !== 'undefined') {
		// Last kbps value
		var kbps = Number((__npk_ping__.ping_kbps).toFixed(2));

		console.log('Current Kpbs: '+kbps);
		console.log('Performance Output');
		console.log(performance);
		console.log(performance.getEntriesByType("resource"));

		document.getElementById("kbps_output").innerHTML = kbps;
		document.getElementById("mbps_output").innerHTML = parseFloat(Math.round((kbps/1000)*100)/100).toFixed(2);
		document.getElementById("resource_output").innerHTML = __npk_ping__.ping_payload_size;
	}

	/* __npk_init_modules(); - 
	 * Maybe we can put this in the main thread, I found performance improvements keeping it here for now though
     	 */
	__npk_init_modules(); 
	/* __npk_init_modules(); */

	/* __npk_loader__.createBundleLoadObjects()  */
	__npk_loader__.createBundleLoadObjects(fallover);
	/*__npk_loader__.createBundleLoadObjects() */

	/* __npk_loader__.loadBundles() */
	__npk_loader__.loadBundles();
	/* __npk_loader__.loadBundles() */

	// If we are in fallover mode we try to ping one more time but this time we'll use a callback
	if(__npk__.ping && fallover === true) {
		__npk_ping__.ping(function() {
			__npk_loader__.createBundleLoadObjects();
			__npk_loader__.loadBundles();
		}); 
	}

	return true;
}; 
/* __npk_init(); */

if(__npk__.ping) {
	// Run when the first ping result comes in, otherwise fallover
	var __npk_init_poll_freq     = 1; // The rate at which will poll init
	var __npk_init_poll_fallover = 100;
	var __npk_init_poll_clock    = 0; 

	if(typeof Promise !== 'undefined' && Promise.toString().indexOf('[native code]') !== -1){
		// Sleep function
		var __npk_sleep = function(time) { return new Promise(resolve => { setTimeout(() => { resolve(); }, time); }); }

		var __npk_init_poll = async function() { 
			__npk_init_poll_clock += __npk_init_poll_freq; 
			await __npk_sleep(__npk_init_poll_freq); 

			if(__npk_ping__.ping_kbps>0) { 

				__npk_init(); 
			} else if(__npk_init_poll_clock>__npk_init_poll_fallover) {
				__npk_init(true); 
			} else { 
				__npk_init_poll(); 
			} 
		};
	} else {
		if(__npk__.debug) { console.log("Promises: false"); }
		var __npk_init_poll = function() { 
			setTimeout(function() { 
				__npk_init_poll_clock += __npk_init_poll_freq; 

				if(__npk__.ping_kbps>0) { 
					__npk_init(); 
				} else if(__npk_init_poll_clock>__npk_init_poll_fallover) { 
					__npk_init(true); 
				} else { 
					__npk_init_poll(); 
				} 
			}, __npk_init_poll_freq); };
	}
	__npk_init_poll();
} else {
	__npk_init(); 
}

if(__npk__.debug && typeof __npk_init_poll_clock !== 'undefined') { 
	console.log('Poll clock: '+__npk_init_poll_clock); 
}

</script>

</body>
</html>
